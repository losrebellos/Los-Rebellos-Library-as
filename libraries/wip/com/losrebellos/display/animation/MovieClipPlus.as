package com.losrebellos.display.animation {	import com.losrebellos.display.invalidate.StageManager;	import com.losrebellos.events.AnimationEvent;	import flash.display.DisplayObject;	import flash.display.FrameLabel;	import flash.display.Graphics;	import flash.display.MovieClip;	import flash.events.Event;	import flash.geom.Rectangle;		/*	 *	 * @author los rebellos	 *	 */	public class MovieClipPlus extends MovieClip implements IMovieClipPlus	{		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// CONSTRUCTOR
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function MovieClipPlus()		{			super();						_graphics = this.graphics;						parseFrames();			createContent();			addContent();		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// CONTENT (template)		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		protected function createContent():void		{					}		protected function addContent():void		{					}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// IGRAPHICS		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		protected var _graphics:Graphics;		public function get g():Graphics		{			return _graphics;		}		public function drawCircle(x:Number = 0, y:Number = 0, radius:Number = 50, color:uint = 0xff0000, alpha:Number = .5):void		{			_graphics.beginFill(color, alpha);			_graphics.drawCircle(x, y, radius);			_graphics.endFill();		}		public function drawRect(x:Number = 0, y:Number = 0, width:Number = 50, height:Number = 50, color:uint = 0xff0000, alpha:Number = .5):void		{			_graphics.beginFill(color, alpha);			_graphics.drawRect(x, y, width, height);			_graphics.endFill();		}		public function drawRoundRect(x:Number = 0, y:Number = 0, width:Number = 50, height:Number = 50, color:uint = 0xff0000, alpha:Number = .5, ellipseWidth:Number = 10, ellipseHeight:Number = undefined):void		{			_graphics.beginFill(color, alpha);			_graphics.drawRoundRect(x, y, width, height, ellipseWidth, ellipseHeight);			_graphics.endFill();		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// SCALE		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function set scale(value:Number):void		{			this.scaleX = this.scaleY = value;		}		public function get scale():Number		{			return (this.scaleX + this.scaleY) / 2;		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// INDEX		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function set index(value:int):void		{			this.setIndex(value);		}		public function get index():int		{			return this.getIndex();		}		protected function setIndex(value : int):Boolean		{			if(parent)			{				parent.setChildIndex(this, value);				return true;			}						return false;		}		protected function getIndex():int		{			return (parent) ? parent.getChildIndex(this) : -1;		}		public function setTopIndex():int		{			if(parent)			{				parent.setChildIndex(this, parent.numChildren - 1);				return parent.numChildren - 1;			}						return -1;		}		public function getAllChildren():Vector.<DisplayObject>		{			var children:Vector.<DisplayObject> = new Vector.<DisplayObject>();			var childrenLength:int = this.numChildren;						for(var i:int = 0; i<childrenLength; i++)			{				children.push(this.getChildAt(i));			}						children.fixed = true;			return children;		}		public function removeAllChildren():void		{			while(this.numChildren)			{				this.removeChildAt(0);			}		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// INTERACTION		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function set mouse(value:Boolean):void		{			this.mouseEnabled = this.mouseChildren = value;		}		public function get mouse():Boolean		{			return !this.mouseEnabled && !this.mouseChildren;		}		public function set button(value:Boolean):void		{			this.buttonMode = this.useHandCursor = value;		}		public function get button():Boolean		{			return !this.buttonMode && !this.useHandCursor;		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// EVENTS		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		override public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = true):void		{			super.addEventListener(type, listener, useCapture, priority, useWeakReference);		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////		// REMOVE / DISPOSE / DESTROY		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function remove(e:Event = null):Boolean		{			if(parent)			{				parent.removeChild(this);								return true;			}						return false;		}		public function dispose(e:Event = null):void		{			remove();			removeAllChildren();						_graphics.clear();			_graphics = null;						_rect = null;		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// INVALIDATE
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function invalidate():void		{			StageManager.addItem(this);		}		// save the resize data		protected var _rect:Rectangle;		public function resize(rect:Rectangle):void		{			_rect = rect;						invalidate();		}		// redraw automatically on stage.invalidate		public function redraw():void		{					}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// STATE
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		private var _state:String = MovieClipState.STOPPED;		public function get state():String		{			return _state;		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// FRAMES
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		protected var frames:Array = [];		private function parseFrames():void		{			var frameLabel:FrameLabel;			for(var i:int = 0; i<this.currentLabels.length; i++)			{				frameLabel = this.currentLabels[i];				frames[frameLabel.frame] = frameLabel.name;			}		}		public function getFrameByLabel(name:String):int		{			return frames.indexOf(name);		}		public function getLabelByFrame(frame:int):String		{			return frames[frame];		}		public function getFrameLabel(frame:Object = null):FrameLabel		{			//if frame is undefined, return the current FrameLabel			if(!frame)			{				return new FrameLabel(this.currentLabel, this.currentFrame);			}						//if frame is a String			if(frame is String)			{				return new FrameLabel(String(frame), frames.indexOf(frame));			}						//if frame is an int			return new FrameLabel("", int(frame));		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// GOTO
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function goto(frame : Object, scene : String = null):void		{			if(_state == MovieClipState.PLAYING)			{				this.cleanStop();				this.startPlayHeadHandler(this.currentFrame, frame, scene, _numLoop);			}			else if(_state == MovieClipState.STOPPED)			{				this.gotoAndStop(frame, scene);			}		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// PLAY
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		override public function play():void		{			this.cleanStop();			this.startPlayHeadHandler(1, this.totalFrames, null, -1);		}		override public function gotoAndPlay(frame:Object, scene:String = null):void		{			this.cleanGotoAndStop(frame, scene);			this.startPlayHeadHandler(1, this.totalFrames, scene, -1);		}		// backward		public function playBackward():void		{			this.cleanStop();			this.startPlayHeadHandler(this.totalFrames, 1, null, -1);		}		public function gotoAndPlayBackward(frame:Object, scene:String = null):void		{			this.cleanGotoAndStop(frame, scene);			this.startPlayHeadHandler(this.totalFrames, 1, scene, -1);		}		// to		public function playTo(frame:Object, scene:String = null, loop:int = 1):void		{			this.cleanStop();			this.startPlayHeadHandler(this.currentFrame, frame, scene, loop);		}		public function gotoAndPlayTo(startFrame:Object, endFrame:Object, scene:String = null, loop:int = 1):void		{			this.cleanGotoAndStop(startFrame, scene);			this.startPlayHeadHandler(startFrame, endFrame, scene, loop);		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// LOOP
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function loop(loop:int = 1):void		{			this.cleanStop();			this.startPlayHeadHandler(1, this.totalFrames, null, loop);		}		public function gotoAndLoop(frame:Object, scene:String = null, loop:int = 1):void		{			this.cleanGotoAndStop(frame, scene);			this.startPlayHeadHandler(1, this.totalFrames, scene, loop);		}		// backward		public function loopBackward(loop:int = 1):void		{			this.cleanStop();			this.startPlayHeadHandler(this.totalFrames, 1, null, loop);		}		public function gotoAndLoopBackward(frame:Object, scene:String = null, loop:int = 1):void		{			this.cleanGotoAndStop(frame, scene);			this.startPlayHeadHandler(this.totalFrames, 1, scene, loop);		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// PLAY HEAD MANAGEMENT
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		protected var _numLoop:int = -1;		protected var _currentScene:String = null;		protected var _startingFrame:FrameLabel;		protected var _targetedFrame:FrameLabel;		protected function startPlayHeadHandler(startFrame:Object, endFrame:Object, scene:String = null, loop:int = 1):void		{			_currentScene = scene;			_numLoop = loop;			_startingFrame = this.getFrameLabel(startFrame);			_targetedFrame = this.getFrameLabel(endFrame);			this.addEventListener(Event.ENTER_FRAME, playHeadHandler);		}		protected function playHeadHandler(e:Event):void		{			_state = MovieClipState.PLAYING;						//events			if(this.currentFrame == 1)			{				this.dispatchEvent(new AnimationEvent(AnimationEvent.FIRST_FRAME));			}			if(this.currentFrame == this.totalFrames)			{				this.dispatchEvent(new AnimationEvent(AnimationEvent.LAST_FRAME));			}			if(this.currentFrame == _startingFrame.frame)			{				this.dispatchEvent(new AnimationEvent(AnimationEvent.STARTING_FRAME));			}						//move play head			if(this.currentFrame < _targetedFrame.frame)			{				this.nextFrame();			}			else if(this.currentFrame > _targetedFrame.frame)			{				this.prevFrame();			}			else			{				this.dispatchEvent(new AnimationEvent(AnimationEvent.ENDING_FRAME));								_numLoop--;				if(_numLoop <= 0)				{					this.stop();				}				else				{					this.gotoAndPlayTo(_startingFrame, _targetedFrame, _currentScene, _numLoop);				}			}		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// STOP
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		override public function gotoAndStop(frame : Object, scene : String = null):void		{			cleanGotoAndStop(frame, scene);						_state = MovieClipState.STOPPED;						this.dispatchEvent(new AnimationEvent(AnimationEvent.STOPPED));		}		override public function stop():void		{			cleanStop();						this.dispatchEvent(new AnimationEvent(AnimationEvent.STOPPED));		}		protected function cleanGotoAndStop(frame : Object, scene : String = null):void		{			this.removeEventListener(Event.ENTER_FRAME, playHeadHandler);						_state = MovieClipState.STOPPED;						super.gotoAndStop(frame, scene);		}		protected function cleanStop():void		{			this.removeEventListener(Event.ENTER_FRAME, playHeadHandler);						_state = MovieClipState.STOPPED;						super.stop();		}						////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// USEFUL FOR STREAMING		// NEED TO BE TESTED
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////		public function seek(percent:Number):void		{			this.goto(int(percent * this.totalFrames));		}		public function getPercentPlayed():Number		{			return this.currentFrame / this.totalFrames;		}	}}