package losrebellos.text {	import losrebellos.display.SpritePlus;	import losrebellos.interfaces.IEvent;	import losrebellos.interfaces.IMotion;	import losrebellos.interfaces.IMouse;	import losrebellos.interfaces.IPlus;	import losrebellos.interfaces.IRender;	import losrebellos.rendering.Render;	import losrebellos.rendering.RenderType;	import flash.display.Bitmap;	import flash.display.DisplayObject;	import flash.events.FocusEvent;	import flash.events.KeyboardEvent;	import flash.geom.Rectangle;	import flash.text.AntiAliasType;	import flash.text.StyleSheet;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.text.TextFormat;	import flash.text.TextLineMetrics;	/*	 *	 * @author los rebellos	 *	 */	public class TextFieldContainer extends SpritePlus implements ITextFieldContainer, IPlus, IMotion, IRender, IMouse, IEvent	{		/*		 * 		 * VARIABLES		 * 		 */		protected var _renderType:String = RenderType.NORMAL;				//fix		protected var center_box_width:Number;				//elements		protected var bmp:Bitmap;		protected var label:TextFieldPlus;						/*		 * 		 * CONSTRUCTOR		 * 		 */		public function TextFieldContainer()		{			super();						label = new TextFieldPlus;			this.addChild(label);						this.multiline = true;			this.wordWrap = true;			this.selectable = false;			this.mouse = false;			this.antiAliasType = AntiAliasType.ADVANCED;			this.embedFonts = true;		}		public static function generateTextFieldContainer(autoSize:String, styleSheet:StyleSheet):TextFieldContainer		{			var tfc:TextFieldContainer = new TextFieldContainer();			tfc.autoSize = autoSize;			tfc.styleSheet = styleSheet;						return tfc;		}						/*		 * 		 * RENDERING		 * 		 */		public function set renderType(value:String):void		{			_renderType = value;						updateRendering();		}		public function get renderType():String		{			return _renderType;		}		public function updateRendering():void		{			refreshPosition();			refreshRendering();		}		public function refreshPosition():void		{			switch(label.autoSize)			{				case TextFieldAutoSize.RIGHT:					label.x = - label.width;					break;				case TextFieldAutoSize.CENTER:					label.x = - label.width / 2;					break;			}		}		public function refreshRendering():void		{			switch(_renderType)			{				case RenderType.BITMAP:					renderAsBitmap();					break;				default:					renderAsNormal();					break;			}		}		protected function renderAsBitmap():void		{			if(bmp)				this.removeChild(bmp);						bmp = getLabelBitmap();			if(bmp)			{				positionBitmap();				this.addChildAt(bmp, 0);			}						if(label.type != TextFieldType.INPUT)				label.visible = false;			else			{				label.addEventListener(FocusEvent.FOCUS_IN, keyDownHandler);				label.addEventListener(FocusEvent.FOCUS_OUT, keyDownHandler);				label.alpha = 0;			}		}		protected function getLabelBitmap():Bitmap		{			switch(label.autoSize)			{				case TextFieldAutoSize.CENTER:					return Render.getBitmap(label, new Rectangle((center_box_width - label.boxWidth) / 2 - 1, 0, center_box_width, label.boxHeight + 1), new RenderType);					break;								default:					return Render.getBitmap(label, new Rectangle(0, 0, label.boxWidth, label.boxHeight + 1), new RenderType);					break;			}		}		protected function positionBitmap():void		{			switch(label.autoSize)			{				case TextFieldAutoSize.CENTER:					bmp.x = - center_box_width / 2;					break;								default:					bmp.x = label.x;					break;			}			bmp.y = label.y;		}		protected function renderAsNormal():void		{			if(bmp)				this.removeChild(bmp);						label.visible = true;						if(label.type == TextFieldType.INPUT)			{				label.removeEventListener(FocusEvent.FOCUS_IN, keyDownHandler);				label.removeEventListener(FocusEvent.FOCUS_OUT, keyDownHandler);				label.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			}		}						/*		 * 		 * INPUT KEY HANDLER		 * IN CASE OF INPUT TEXTFIELD TYPE AND BITMAP RENDERING		 * 		 * "NOT WORKING AT THE MOMENT"		 * 		 */		protected function focusHandler(e:FocusEvent):void		{			if(e.type == FocusEvent.FOCUS_IN)				label.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			else if(e.type == FocusEvent.FOCUS_OUT)				label.removeEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);		}		protected function keyDownHandler(e:KeyboardEvent):void		{			stage.focus = stage;			renderAsBitmap();			stage.focus = label;		}				/*		 * 		 * SETTER & GETTER		 * 		 */		public function set css(value:String):void		{			label.css = value;		}		public function get css():String		{			return label.css;		}		public function setSimpleCSSClass(style:String, value:String):void		{			label.setSimpleCSSClass(style, value);						this.updateRendering();		}		public function setSimpleCSSID(style:String, value:String):void		{			label.setSimpleCSSID(style, value);						this.updateRendering();		}						/*		 * 		 * MOUSE		 * 		 */		override public function set mouse(value:Boolean):void		{			super.mouse = value;			label.mouse = value;		}		override public function get mouse():Boolean		{			return !super.mouse && !label.mouse;		}						/*		 * 		 * POSITION		 * 		 */		override public function set x(value:Number):void		{			super.x = value;						updateRendering();		}						/*		 * 		 * SIZE		 * 		 */		override public function set width(value:Number):void		{			center_box_width = value;			label.width = value;						updateRendering();		}		override public function set height(value:Number):void		{			label.height = value;						updateRendering();		}		override public function get width():Number		{			return label.width;		}		override public function get height():Number		{			return label.height;		}		public function get boxWidth():Number		{			return super.width;		}		public function get boxHeight():Number		{			return super.height;		}						/*		 * 		 * CLASSIC TEXTFIELD METHODS		 * 		 * like that label stay "protected"		 * encapsulation, encapsulation, encapsulation!!!		 * 		 */		public function replaceText(beginIndex : int, endIndex : int, newText : String):void		{			label.replaceText(beginIndex, endIndex, newText);						updateRendering();		}		public function get maxScrollH() : int		{			return label.maxScrollH;		}		public function get numLines() : int		{			return label.numLines;		}		public function get scrollH() : int		{			return label.scrollH;		}		public function get caretIndex() : int		{			return label.caretIndex;		}		public function get maxScrollV() : int		{			return label.maxScrollV;		}		public function getImageReference(id : String) : DisplayObject		{			return label.getImageReference(id);		}		public function get scrollV() : int		{			return label.scrollV;		}		public function get border() : Boolean		{			return label.border;		}		public function get text() : String		{			return label.text;		}		public function get background() : Boolean		{			return label.background;		}		public function getCharBoundaries(charIndex : int) : Rectangle		{			return label.getCharBoundaries(charIndex);		}		public function set borderColor(value : uint) : void		{			label.borderColor = value;						updateRendering();		}		public function set scrollH(value : int) : void		{			label.scrollH = value;		}		public function getFirstCharInParagraph(charIndex : int) : int		{			return label.getFirstCharInParagraph(charIndex);		}		public function get type() : String		{			return label.type;		}		public function replaceSelectedText(value : String) : void		{			label.replaceSelectedText(value);						updateRendering();		}		public function getRawText() : String		{			return label.getRawText();		}		public function get alwaysShowSelection() : Boolean		{			return label.alwaysShowSelection;		}		public function get sharpness() : Number		{			return label.sharpness;		}		public function get textColor() : uint		{			return label.textColor;		}		public function set defaultTextFormat(format : TextFormat) : void		{			label.defaultTextFormat = format;						updateRendering();		}		public function get condenseWhite() : Boolean		{			return label.condenseWhite;		}		public function get autoSize() : String		{			return label.autoSize;		}		public function set scrollV(value : int) : void		{			label.scrollV = value;		}		public function set border(value : Boolean) : void		{			label.border = value;						updateRendering();		}		public function get styleSheet() : StyleSheet		{			return label.styleSheet;		}		public function set background(value : Boolean) : void		{			label.background;						updateRendering();		}		public function set embedFonts(value : Boolean) : void		{			label.embedFonts = value;						updateRendering();		}		public function get displayAsPassword() : Boolean		{			return label.displayAsPassword;		}		public function get antiAliasType() : String		{			return label.antiAliasType;		}		public function set multiline(value : Boolean) : void		{			label.multiline = value;						updateRendering();		}		public function get selectionEndIndex() : int		{			return label.selectionEndIndex;		}		public function set styleSheet(value : StyleSheet) : void		{			label.styleSheet = value;						updateRendering();		}		public function set mouseWheelEnabled(value : Boolean) : void		{			label.mouseWheelEnabled = value;		}		public function get selectedText() : String		{			return label.selectedText;		}		public function get thickness() : Number		{			return label.thickness;		}		public function getLineIndexAtPoint(x : Number, y : Number) : int		{			return label.getLineIndexAtPoint(x, y);		}		public function appendText(newText : String) : void		{			label.appendText(newText);		}		public function get selectionBeginIndex() : int		{			return label.selectionBeginIndex;		}		public function set textColor(value : uint) : void		{			label.textColor = value;						updateRendering();		}		public function set text(value : String) : void		{			label.text = value;						updateRendering();		}		public function get bottomScrollV() : int		{			return label.bottomScrollV;		}		public function get htmlText() : String		{			return label.htmlText;		}		public function set alwaysShowSelection(value : Boolean) : void		{			label.alwaysShowSelection = value;		}		public function set sharpness(value : Number) : void		{			label.sharpness = value;						updateRendering();		}		public function get selectable() : Boolean		{			return label.selectable;		}		public function getLineIndexOfChar(charIndex : int) : int		{			return label.getLineIndexOfChar(charIndex);		}		public function set restrict(value : String) : void		{			label.restrict = value;		}		public function set gridFitType(gridFitType : String) : void		{			label.gridFitType = gridFitType;		}		public function setSelection(beginIndex : int, endIndex : int) : void		{			label.setSelection(beginIndex, endIndex);						updateRendering();		}		public function getTextFormat(beginIndex : int = -1, endIndex : int = -1) : TextFormat		{			return label.getTextFormat(beginIndex, endIndex);		}		public function setTextFormat(format : TextFormat, beginIndex : int = -1, endIndex : int = -1) : void		{			label.setTextFormat(format, beginIndex, endIndex);						updateRendering();		}		public function set type(value : String) : void		{			label.type = value;						updateRendering();		}		public function get borderColor() : uint		{			return label.borderColor;		}		public function set condenseWhite(value : Boolean) : void		{			label.condenseWhite = value;						updateRendering();		}		public function get textWidth() : Number		{			return label.textWidth;		}		public function getTextRuns(beginIndex : int = 0, endIndex : int = 2147483647) : Array		{			return label.getTextRuns(beginIndex, endIndex);		}		public function getLineOffset(lineIndex : int) : int		{			return label.getLineOffset(lineIndex);		}		public function get wordWrap() : Boolean		{			return label.wordWrap;		}		public function get useRichTextClipboard() : Boolean		{			return label.useRichTextClipboard;		}		public function set autoSize(value : String) : void		{			if(value.split("/").indexOf(TextFieldAutoSizePlus.AUTO) != -1)			{				this.multiline = this.wordWrap = false;				value = value.split("/")[0];			}						center_box_width = label.boxWidth;			label.autoSize = value;						updateRendering();		}		public function get defaultTextFormat() : TextFormat		{			return label.defaultTextFormat;		}		public function get multiline() : Boolean		{			return label.multiline;		}		public function set useRichTextClipboard(value : Boolean) : void		{			label.useRichTextClipboard = value;		}		public function set backgroundColor(value : uint) : void		{			label.backgroundColor = value;						updateRendering();		}		public function get embedFonts() : Boolean		{			return label.embedFonts;		}		public function set selectable(value : Boolean) : void		{			label.selectable = value;		}		public function get textHeight() : Number		{			return label.textHeight;		}		public function getXMLText(beginIndex : int = 0, endIndex : int = 2147483647) : String		{			return label.getXMLText(beginIndex, endIndex);		}		public function set displayAsPassword(value : Boolean) : void		{			label.displayAsPassword = value;						updateRendering();		}		public function getLineText(lineIndex : int) : String		{			return label.getLineText(lineIndex);		}		public function set maxChars(value : int) : void		{			label.maxChars = value;		}		public function get mouseWheelEnabled() : Boolean		{			return label.mouseWheelEnabled;		}		public function get restrict() : String		{			return label.restrict;		}		public function get gridFitType() : String		{			return label.gridFitType;		}		public function getParagraphLength(charIndex : int) : int		{			return label.getParagraphLength(charIndex);		}		public function set antiAliasType(antiAliasType : String) : void		{			label.antiAliasType = antiAliasType;						updateRendering();		}		public function get backgroundColor() : uint		{			return label.backgroundColor;		}		public function getCharIndexAtPoint(x : Number, y : Number) : int		{			return label.getCharIndexAtPoint(x, y);		}		public function get maxChars() : int		{			return label.maxChars;		}		public function get length() : int		{			return label.length;		}		public function set thickness(value : Number) : void		{			label.thickness = value;						updateRendering();		}		public function insertXMLText(beginIndex : int, endIndex : int, richText : String, pasting : Boolean = false) : void		{			label.insertXMLText(beginIndex, endIndex, richText, pasting);		}		public function set wordWrap(value : Boolean) : void		{			label.wordWrap = value;						updateRendering();		}		public function set htmlText(value : String) : void		{			label.htmlText = value;						updateRendering();		}		public function getLineMetrics(lineIndex : int) : TextLineMetrics		{			return label.getLineMetrics(lineIndex);		}		public function getLineLength(lineIndex : int) : int		{			return label.getLineLength(lineIndex);		}	}}